import re

# defines a list of token types along with their corresponding regular expression patterns
TOKEN_TYPES = [
    ("NUMBER", r"\d+"),
    ("STRING", r'"[^"]*"'),
    ("VARIABLE", r"[a-zA-Z_][a-zA-Z0-9_]*"),
    ("ASSIGN", r"="),
    ("PLUS", r"\+"),
    ("MINUS", r"-"),
    ("MULTIPLY", r"\*"),
    ("DIVIDE", r"/"),
    ("LPAREN", r"\("),
    ("RPAREN", r"\)"),
    ("WHITESPACE", r"\s+"),
]


# It extracts tokens from the source based on the matched patterns and builds a list of tokens.
def tokenize(src) -> list:
    tokens = []
    while src:
        for token_type, pattern in TOKEN_TYPES:
            match = re.match(pattern, src)
            if match:
                token_value = match.group(0)
                if token_type != "WHITESPACE":
                    tokens.append((token_type, token_value))
                src = src[match.end() :]
                break
        else:
            raise Exception("Invalid character: " + src[0])
    return tokens




class Parser:
    def __init__(self, tokens):
        # initializes the parser with a list of tokens generated by the tokenizer and sets the current token index to 0.
        self.tokens = tokens
        self.current_token_index = 0

    #  is the entry point for parsing. It starts parsing from the assignment() method.
    def parse(self):
        return self.assignment()

    # This method parses assignment statements, which consist of a variable name, an assignment operator '=', and an expression. 
    # It calls the expression() method to parse the right-hand side of the assignment.
    def assignment(self):
        variable_name_token = self.consume("VARIABLE") # checks if it matches the expected token type, which is a variable name.
        self.consume("ASSIGN") # verifies that the next token in the list is indeed the assignment operator.
        # After successfully parsing the variable name and the assignment operator
        # It calls the expression() method to parse the expression. This method handles the parsing of arithmetic expressions
        expression_value = self.expression()
        return ("=", variable_name_token[1], expression_value)

    # This method parses factors in arithmetic expressions. Factors can be numbers, strings, variables, or expressions enclosed in parentheses.
    def factor(self):
        # checks if it matches any of the expected token types
        # returns a tuple containing the token type and its corresponding value
        token_type, token_value = self.consume("NUMBER", "STRING", "VARIABLE", "LPAREN")
        if token_type == "NUMBER" or token_type == "STRING" or token_type == "VARIABLE":
            return token_value # If the token type is "NUMBER", "STRING", or "VARIABLE", it means the factor is a simple value (number, string, or variable name). In this case, it returns the token value.
        elif token_type == "LPAREN":
            expression_value = self.expression()
            self.consume("RPAREN")
            return expression_value # If the token type is "LPAREN", . It proceeds to parse the enclosed expression.


    # method is responsible for parsing terms within arithmetic expressions. A term is a combination of factors multiplied or divided together.
    def term(self):
        # It starts by calling the factor() method to parse the first factor in the term.
        result = self.factor()
        while self.current_token_index < len(self.tokens):
            if self.tokens[self.current_token_index][0] in {"MULTIPLY", "DIVIDE"}: #it checks if the next token in the token list is a multiplication ("MULTIPLY") or division ("DIVIDE") operator.
                operator_token = self.consume("MULTIPLY", "DIVIDE")
                result = (operator_token[1], result, self.factor())
            else:
                break
        return result

    #  parses arithmetic expressions. An expression consists of one or more terms combined with addition or subtraction operations.
    # 
    def expression(self):
        result = self.term() # parse the first term in the expression.
        while self.current_token_index < len(self.tokens):
            # If the next token is one of these operators, it proceeds to parse the next term and perform addition or subtraction operation.
            if self.tokens[self.current_token_index][0] in {"PLUS", "MINUS"}:
                operator_token = self.consume("PLUS", "MINUS")
                result = (operator_token[1], result, self.term())
            else:
                break # If the next token is not a plus or minus operator, the loop break
        return result

    # provides a mechanism for the parser to consume tokens from the token list while ensuring that they match the expected token types.
    def consume(self, *expected_token_types):
        if self.current_token_index >= len(self.tokens):  # f the current token index exceeds the total number of tokens, it raises a ValueError indicating an unexpected end of input.
            raise ValueError("Unexpected end of input")
        current_token = self.tokens[self.current_token_index]  # It retrieves the current token from the token list based on the current token index.
        if current_token[0] not in expected_token_types:
            raise ValueError(f"Expected one of {expected_token_types}, got {current_token}")
        
        # If the current token matches one of the expected token types, it increments the current token index (self.current_token_index) to move to the next token in the list.
        self.current_token_index += 1
        return current_token




src = """x = (1 + 2)
y = 4 - b
z = (y + 4) - b"""

src = src.split("\n")

for line in src:
    tokens = tokenize(line)
    parser = Parser(tokens)
    parse_tree = parser.parse()
    print(parse_tree)